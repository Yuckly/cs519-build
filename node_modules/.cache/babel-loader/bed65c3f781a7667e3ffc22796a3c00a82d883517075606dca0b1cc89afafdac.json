{"ast":null,"code":"import _regeneratorRuntime from \"/Users/jiasonghuang/Desktop/cs519_diagnostic/diagnostic-test-Yuckly/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/jiasonghuang/Desktop/cs519_diagnostic/diagnostic-test-Yuckly/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _toConsumableArray from \"/Users/jiasonghuang/Desktop/cs519_diagnostic/diagnostic-test-Yuckly/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { ownerDocument } from '@mui/material/utils';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridVisibleRowCountSelector } from '../filter/gridFilterSelector';\nimport { gridColumnDefinitionsSelector, gridColumnVisibilityModelSelector } from '../columns/gridColumnsSelector';\nimport { gridDensityTotalHeaderHeightSelector } from '../density/densitySelector';\nimport { gridClasses } from '../../../constants/gridClasses';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { gridRowsMetaSelector } from '../rows/gridRowsMetaSelector';\nimport { getColumnsToExport } from './utils';\nimport { useGridRegisterPipeProcessor } from '../../core/pipeProcessing';\nimport { GridPrintExportMenuItem } from '../../../components/toolbar/GridToolbarExport';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction raf() {\n  return new Promise(function (resolve) {\n    requestAnimationFrame(function () {\n      resolve();\n    });\n  });\n}\nfunction getChromeVersion() {\n  var raw = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n  return raw ? parseInt(raw[2], 10) : null;\n}\n\n/**\n * @requires useGridColumns (state)\n * @requires useGridFilter (state)\n * @requires useGridSorting (state)\n * @requires useGridParamsApi (method)\n */\nexport var useGridPrintExport = function useGridPrintExport(apiRef, props) {\n  var logger = useGridLogger(apiRef, 'useGridPrintExport');\n  var doc = React.useRef(null);\n  var previousGridState = React.useRef(null);\n  var previousColumnVisibility = React.useRef({});\n  React.useEffect(function () {\n    doc.current = ownerDocument(apiRef.current.rootElementRef.current);\n  }, [apiRef]); // Returns a promise because updateColumns triggers state update and\n  // the new state needs to be in place before the grid can be sized correctly\n\n  var updateGridColumnsForPrint = React.useCallback(function (fields, allColumns) {\n    return new Promise(function (resolve) {\n      // TODO remove unused Promise\n      if (!fields && !allColumns) {\n        resolve();\n        return;\n      }\n      var exportedColumnFields = getColumnsToExport({\n        apiRef: apiRef,\n        options: {\n          fields: fields,\n          allColumns: allColumns\n        }\n      }).map(function (column) {\n        return column.field;\n      });\n      var columns = gridColumnDefinitionsSelector(apiRef);\n      var newColumnVisibilityModel = {};\n      columns.forEach(function (column) {\n        newColumnVisibilityModel[column.field] = exportedColumnFields.includes(column.field);\n      });\n      apiRef.current.setColumnVisibilityModel(newColumnVisibilityModel);\n      resolve();\n    });\n  }, [apiRef]); // TODO move outside of this scope and remove React.useCallback\n\n  var buildPrintWindow = React.useCallback(function (title) {\n    var iframeEl = document.createElement('iframe');\n    iframeEl.style.position = 'absolute';\n    iframeEl.style.width = '0px';\n    iframeEl.style.height = '0px';\n    iframeEl.title = title || document.title;\n    return iframeEl;\n  }, []);\n  var handlePrintWindowLoad = React.useCallback(function (printWindow, options) {\n    var _querySelector, _querySelector2;\n    var normalizeOptions = _extends({\n      copyStyles: true,\n      hideToolbar: false,\n      hideFooter: false\n    }, options);\n    var printDoc = printWindow.contentDocument;\n    if (!printDoc) {\n      return;\n    }\n    var totalHeaderHeight = gridDensityTotalHeaderHeightSelector(apiRef);\n    var rowsMeta = gridRowsMetaSelector(apiRef.current.state);\n    var gridRootElement = apiRef.current.rootElementRef.current;\n    var gridClone = gridRootElement.cloneNode(true);\n    var gridCloneViewport = gridClone.querySelector(\".\".concat(gridClasses.virtualScroller)); // Expand the viewport window to prevent clipping\n\n    gridCloneViewport.style.height = 'auto';\n    gridCloneViewport.style.width = 'auto';\n    gridCloneViewport.parentElement.style.width = 'auto';\n    gridCloneViewport.parentElement.style.height = 'auto'; // Allow to overflow to not hide the border of the last row\n\n    var gridMain = gridClone.querySelector(\".\".concat(gridClasses.main));\n    gridMain.style.overflow = 'visible';\n    var chromeVersion = getChromeVersion();\n    if (chromeVersion && chromeVersion >= 108) {\n      // See https://support.google.com/chrome/thread/191619088?hl=en&msgid=193009642\n      gridClone.style.contain = 'size';\n    }\n    var columnHeaders = gridClone.querySelector(\".\".concat(gridClasses.columnHeaders));\n    var columnHeadersInner = columnHeaders.querySelector(\".\".concat(gridClasses.columnHeadersInner));\n    columnHeadersInner.style.width = '100%';\n    var gridToolbarElementHeight = ((_querySelector = gridRootElement.querySelector(\".\".concat(gridClasses.toolbarContainer))) == null ? void 0 : _querySelector.clientHeight) || 0;\n    var gridFooterElementHeight = ((_querySelector2 = gridRootElement.querySelector(\".\".concat(gridClasses.footerContainer))) == null ? void 0 : _querySelector2.clientHeight) || 0;\n    if (normalizeOptions.hideToolbar) {\n      var _gridClone$querySelec;\n      (_gridClone$querySelec = gridClone.querySelector(\".\".concat(gridClasses.toolbarContainer))) == null ? void 0 : _gridClone$querySelec.remove();\n      gridToolbarElementHeight = 0;\n    }\n    if (normalizeOptions.hideFooter) {\n      var _gridClone$querySelec2;\n      (_gridClone$querySelec2 = gridClone.querySelector(\".\".concat(gridClasses.footerContainer))) == null ? void 0 : _gridClone$querySelec2.remove();\n      gridFooterElementHeight = 0;\n    } // Expand container height to accommodate all rows\n\n    gridClone.style.height = \"\".concat(rowsMeta.currentPageTotalHeight + totalHeaderHeight + gridToolbarElementHeight + gridFooterElementHeight, \"px\"); // printDoc.body.appendChild(gridClone); should be enough but a clone isolation bug in Safari\n    // prevents us to do it\n\n    var container = document.createElement('div');\n    container.appendChild(gridClone);\n    printDoc.body.innerHTML = container.innerHTML;\n    var defaultPageStyle = typeof normalizeOptions.pageStyle === 'function' ? normalizeOptions.pageStyle() : normalizeOptions.pageStyle;\n    if (typeof defaultPageStyle === 'string') {\n      // TODO custom styles should always win\n      var styleElement = printDoc.createElement('style');\n      styleElement.appendChild(printDoc.createTextNode(defaultPageStyle));\n      printDoc.head.appendChild(styleElement);\n    }\n    if (normalizeOptions.bodyClassName) {\n      var _printDoc$body$classL;\n      (_printDoc$body$classL = printDoc.body.classList).add.apply(_printDoc$body$classL, _toConsumableArray(normalizeOptions.bodyClassName.split(' ')));\n    }\n    if (normalizeOptions.copyStyles) {\n      var headStyleElements = doc.current.querySelectorAll(\"style, link[rel='stylesheet']\");\n      for (var i = 0; i < headStyleElements.length; i += 1) {\n        var node = headStyleElements[i];\n        if (node.tagName === 'STYLE') {\n          var newHeadStyleElements = printDoc.createElement(node.tagName);\n          var sheet = node.sheet;\n          if (sheet) {\n            var styleCSS = ''; // NOTE: for-of is not supported by IE\n\n            for (var j = 0; j < sheet.cssRules.length; j += 1) {\n              if (typeof sheet.cssRules[j].cssText === 'string') {\n                styleCSS += \"\".concat(sheet.cssRules[j].cssText, \"\\r\\n\");\n              }\n            }\n            newHeadStyleElements.appendChild(printDoc.createTextNode(styleCSS));\n            printDoc.head.appendChild(newHeadStyleElements);\n          }\n        } else if (node.getAttribute('href')) {\n          // If `href` tag is empty, avoid loading these links\n          var _newHeadStyleElements = printDoc.createElement(node.tagName);\n          for (var _j = 0; _j < node.attributes.length; _j += 1) {\n            var attr = node.attributes[_j];\n            if (attr) {\n              _newHeadStyleElements.setAttribute(attr.nodeName, attr.nodeValue || '');\n            }\n          }\n          printDoc.head.appendChild(_newHeadStyleElements);\n        }\n      }\n    } // Trigger print\n\n    if (process.env.NODE_ENV !== 'test') {\n      printWindow.contentWindow.print();\n    }\n  }, [apiRef, doc]);\n  var handlePrintWindowAfterPrint = React.useCallback(function (printWindow) {\n    var _previousGridState$cu, _previousGridState$cu2;\n\n    // Remove the print iframe\n    doc.current.body.removeChild(printWindow); // Revert grid to previous state\n\n    apiRef.current.restoreState(previousGridState.current || {});\n    if (!((_previousGridState$cu = previousGridState.current) != null && (_previousGridState$cu2 = _previousGridState$cu.columns) != null && _previousGridState$cu2.columnVisibilityModel)) {\n      // if the apiRef.current.exportState(); did not exported the column visibility, we update it\n      apiRef.current.setColumnVisibilityModel(previousColumnVisibility.current);\n    }\n    apiRef.current.unstable_enableVirtualization(); // Clear local state\n\n    previousGridState.current = null;\n    previousColumnVisibility.current = {};\n  }, [apiRef]);\n  var exportDataAsPrint = React.useCallback( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n      var visibleRowCount, printWindow;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            logger.debug(\"Export data as Print\");\n            if (apiRef.current.rootElementRef.current) {\n              _context.next = 3;\n              break;\n            }\n            throw new Error('MUI: No grid root element available.');\n          case 3:\n            previousGridState.current = apiRef.current.exportState(); // It appends that the visibility model is not exported, especially if columnVisibility is not controlled\n\n            previousColumnVisibility.current = gridColumnVisibilityModelSelector(apiRef);\n            if (props.pagination) {\n              visibleRowCount = gridVisibleRowCountSelector(apiRef);\n              apiRef.current.setPageSize(visibleRowCount);\n            }\n            _context.next = 8;\n            return updateGridColumnsForPrint(options == null ? void 0 : options.fields, options == null ? void 0 : options.allColumns);\n          case 8:\n            apiRef.current.unstable_disableVirtualization();\n            _context.next = 11;\n            return raf();\n          case 11:\n            // wait for the state changes to take action\n            printWindow = buildPrintWindow(options == null ? void 0 : options.fileName);\n            if (process.env.NODE_ENV === 'test') {\n              doc.current.body.appendChild(printWindow); // In test env, run the all pipeline without waiting for loading\n\n              handlePrintWindowLoad(printWindow, options);\n              handlePrintWindowAfterPrint(printWindow);\n            } else {\n              printWindow.onload = function () {\n                handlePrintWindowLoad(printWindow, options);\n                var mediaQueryList = printWindow.contentWindow.matchMedia('print');\n                mediaQueryList.addEventListener('change', function (mql) {\n                  var isAfterPrint = mql.matches === false;\n                  if (isAfterPrint) {\n                    handlePrintWindowAfterPrint(printWindow);\n                  }\n                });\n              };\n              doc.current.body.appendChild(printWindow);\n            }\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }(), [props, logger, apiRef, buildPrintWindow, handlePrintWindowLoad, handlePrintWindowAfterPrint, updateGridColumnsForPrint]);\n  var printExportApi = {\n    exportDataAsPrint: exportDataAsPrint\n  };\n  useGridApiMethod(apiRef, printExportApi, 'GridPrintExportApi');\n  /**\n   * PRE-PROCESSING\n   */\n\n  var addExportMenuButtons = React.useCallback(function (initialValue, options) {\n    var _options$printOptions;\n    if ((_options$printOptions = options.printOptions) != null && _options$printOptions.disableToolbarButton) {\n      return initialValue;\n    }\n    return [].concat(_toConsumableArray(initialValue), [{\n      component: /*#__PURE__*/_jsx(GridPrintExportMenuItem, {\n        options: options.printOptions\n      }),\n      componentName: 'printExport'\n    }]);\n  }, []);\n  useGridRegisterPipeProcessor(apiRef, 'exportMenu', addExportMenuButtons);\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}